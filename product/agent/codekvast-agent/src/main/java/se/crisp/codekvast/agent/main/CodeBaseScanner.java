package se.crisp.codekvast.agent.main;

import lombok.extern.slf4j.Slf4j;
import org.reflections.Reflections;
import org.reflections.scanners.SubTypesScanner;
import org.springframework.stereotype.Component;
import org.xml.sax.helpers.DefaultHandler;
import se.crisp.codekvast.agent.util.SignatureUtils;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URLClassLoader;
import java.util.List;

import static java.util.Arrays.asList;

/**
 * Analyzes a code base and detects public methods. Uses the org.reflections for retrieving method signature data.
 *
 * It also contains support for mapping synthetic methods generated by runtime byte code manipulation frameworks back to the declared method
 * as it appears in the source code.
 *
 * @author Olle Hallin
 */
@Slf4j
@Component
class CodeBaseScanner {

    void getPublicMethodSignatures(CodeBase codeBase) {
        URLClassLoader appClassLoader = new URLClassLoader(codeBase.getUrls(), System.class.getClassLoader());

        List<String> packagePrefixes = codeBase.getConfig().getNormalizedPackagePrefixes();
        for (String packagePrefix : packagePrefixes) {
            Reflections reflections = new Reflections(packagePrefix, appClassLoader, new SubTypesScanner(false));

            for (Class<?> rootClass : asList(Object.class, Enum.class, Thread.class, DefaultHandler.class, Exception.class)) {
                for (Class<?> clazz : reflections.getSubTypesOf(rootClass)) {
                    findPublicMethods(codeBase, packagePrefix, clazz);
                }
            }
        }
    }

    void findPublicMethods(CodeBase codeBase, String packagePrefix, Class<?> clazz) {
        log.debug("Analyzing {}", clazz);
        try {
            Method[] methods = clazz.getMethods();

            for (Method method : methods) {
                if (Modifier.isPublic(method.getModifiers())) {

                    // Some AOP frameworks (e.g., Guice) push methods from a base class down to the subclasses created in runtime.
                    // We need to map those back to the original declaring signature, or else the original,
                    // declared method will look unused.


                    String thisSignature = SignatureUtils.makeSignatureString(clazz, method);
                    String declaringSignature =
                            SignatureUtils.makeSignatureString(findDeclaringClass(method.getDeclaringClass(), method, packagePrefix),
                                                               method);

                    codeBase.addSignature(thisSignature, declaringSignature);
                }
            }

            for (Class<?> innerClass : clazz.getDeclaredClasses()) {
                findPublicMethods(codeBase, packagePrefix, innerClass);
            }
        } catch (NoClassDefFoundError e) {
            log.warn("Cannot analyze {}: {}", clazz, e.toString());
        }
    }

    private Class findDeclaringClass(Class<?> clazz, Method method, String packagePrefix) {
        if (clazz == null) {
            return null;
        }
        String pkg = clazz.getPackage().getName();
        if (!pkg.startsWith(packagePrefix)) {
            return null;
        }
        try {
            clazz.getDeclaredMethod(method.getName(), method.getParameterTypes());
            return clazz;
        } catch (NoSuchMethodException ignore) {
        }
        return findDeclaringClass(clazz.getSuperclass(), method, packagePrefix);
    }

}
