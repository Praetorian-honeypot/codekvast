buildscript {
    dependencies {
        classpath "org.flywaydb:flyway-gradle-plugin:3.1"
    }
}
plugins {
    id 'java'
    id 'application'
    id 'jacoco'
    id 'com.ofg.uptodate' version '1.5.0'
    id "com.moowork.node" version "0.8"
    // id "com.eriwen.gradle.js" version "1.12.1"
    // id "com.eriwen.gradle.css" version "1.11.1"
}
apply plugin: 'spring-boot'
apply plugin: 'flyway'
apply from: "$rootDir/gradle/java-8.gradle"

description = "The main Codekvast server"
archivesBaseName = "codekvast-server"
version = project.parent.parent.version
mainClassName = "se.crisp.codekvast.server.codekvast_server.CodekvastServerApplication"

configurations {
    springLoaded
    webjar
    h2server
}

sourceSets {
    integTest {
        java.srcDir file('src/integTest/java')
        resources.srcDir file('src/integTest/resources')
    }
}

task integTest(type: Test) {
    group = "Verification"
    description = "Runs all integration tests"

    testClassesDir = sourceSets.integTest.output.classesDir
    classpath = sourceSets.integTest.runtimeClasspath
}

check.dependsOn integTest

def webjars = ['org.webjars:jquery:2.1.3',
               'org.webjars:angularjs:1.3.15',
               'org.webjars:angular-ui-bootstrap:0.12.1-1',
               'org.webjars:sockjs-client:0.3.4-1',
               'org.webjars:stomp-websocket:2.3.3',
               'org.webjars:bootstrap:3.3.4']


dependencies {
    compile lombok
    compile project(':product:server:agent-api')
    compile project(':product:support:websupport')
    compile 'ch.qos.logback:logback-classic'

    compile 'org.springframework.boot:spring-boot-starter-jdbc'
    compile 'org.springframework.boot:spring-boot-starter-web'
    compile 'org.springframework.boot:spring-boot-starter-websocket'
    compile 'org.springframework.boot:spring-boot-starter-thymeleaf'
    compile 'org.springframework.boot:spring-boot-starter-security'
    compile 'org.springframework.boot:spring-boot-starter-actuator'
    compile 'org.springframework:spring-messaging'
    compile 'org.springframework.session:spring-session:1.0.1.RELEASE'
    compile 'org.springframework.session:spring-session-data-redis:1.0.1.RELEASE'
    compile 'com.h2database:h2'
    compile 'org.flywaydb:flyway-core'
    compile 'com.orange.redis-embedded:embedded-redis:0.6'

    runtime project(':product:support:websupport')
    runtime 'org.hibernate:hibernate-validator'
    runtime 'org.springframework.data:spring-data-redis:1.5.0.RELEASE'
    runtime webjars

    testCompile 'org.springframework.boot:spring-boot-starter-test'
    testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'
    testCompile 'org.spockframework:spock-spring:1.0-groovy-2.4'

    integTestCompile sourceSets.main.output
    integTestCompile sourceSets.test.output
    integTestCompile configurations.testCompile
    integTestRuntime configurations.testRuntime

    springLoaded springLoadedAgent

    webjar webjars

    h2server 'com.h2database:h2'
    h2server 'ch.qos.logback:logback-classic'
}

import org.apache.tools.ant.filters.ReplaceTokens

processResources {
    from(sourceSets.main.resources.srcDirs) {
        include '**/application.properties'
        filter(ReplaceTokens, tokens: gitVersionTokens + ['gradle.name'          : archivesBaseName,
                                                          'gradle.description': project.description,
                                                          'gradle.version'       : project.version,
                                                          'gradle.displayVersion': codekvastDisplayVersion]
        )
    }
}

applicationDistribution.from("src/main/resources") {
    into "conf"
    include "logback.xml", "default.properties"
    rename {
        def name = it == "default.properties" ? "codekvast-server.properties" : it
        "${name}.sample.${version}"
    }
}

startScripts {
    doLast {
        outputs.files.each { script ->
            logger.info "Adjusting start script {} ...", script.name
            if (script.name.toLowerCase().endsWith('.bat')) {
                script.text = script.text
                        .replace('CLASSPATH=%APP_HOME%\\lib', 'CLASSPATH=%APP_HOME%\\conf\\;%APP_HOME%\\lib')
            } else {
                script.text = script.text
                        .replace('APP_HOME=', 'export APP_HOME=')
                        .replace('CLASSPATH=$APP_HOME/lib', 'CLASSPATH=$APP_HOME/conf/:$APP_HOME/lib')
            }
        }
    }
}

ext.databasePath = file("build/database/codekvast")

run {
    jvmArgs = ['-ea']
    args = ["--codekvast.databasePath=tcp://localhost/$buildDir/database"]
}

bootRun {
    jvmArgs = [
            '-ea',
            "-javaagent:${configurations.springLoaded.asPath}",
            '-noverify',
            '-Dspring.thymeleaf.cache=false',
            '-Dspring.messages.cacheSeconds=1'
    ]
    args = ["--codekvast.databasePath=tcp://localhost/$buildDir/database"]
}

jacoco {
    applyTo run
}

task coverageReport(type: JacocoReport) {
    group "Documentation"
    description "Generates a test coverage report"
    sourceSets sourceSets.main

    // One could do
    // executionData integTest, run
    // but then *all* of build/jacoco/integTest.exec and run.exec  must exist, or else the report will be skipped.
    // Instead, build a report on what execution data we happen to have.

    enabled = false
    def jacocoDir = file("build/jacoco")
    if (jacocoDir.exists()) {
        jacocoDir.eachFileMatch(~/.*\.exec/) { executionData it; enabled = true }
    }

    reports {
        xml.enabled false
        csv.enabled false
        html.destination "${buildDir}/reports/coverage"
    }
}
build.dependsOn coverageReport

node {
    version = '0.10.35'
    npmVersion = '2.1.17'
    download = true
    workDir = file(".nodejs")
}

task copyWebjars(type: Sync) {
    // Collect all webjars into a folder so that they easily can be unpacked
    from configurations.webjar
    into file("build/webjars")
}

task unpackWebjars {
    // Unpack the webjars so that the Jasmine tests can reference them with invariant
    // (i.e., non-versioned) names...
    dependsOn copyWebjars

    def webjarsDir = file("build/webjars")
    def explodedDir = file("build/webjarJs")

    inputs.files copyWebjars
    outputs.dir explodedDir

    doLast {
        webjarsDir.eachFile { file ->
            copy {
                from zipTree(file)
                include "**/*.js"
                exclude "**/*.min.js"
                into explodedDir
                eachFile { FileCopyDetails details ->
                    logger.debug "Copying {}", details.path
                    // Eliminate everything before the last "/"
                    details.path = details.name
                }
            }
        }
    }
}

task jasmineSingleRun(type: NpmTask) {
    group = 'Verification'
    description = 'Runs the Jasmine tests a single time.'
    dependsOn npmInstall, unpackWebjars

    def jasmineLog = file('build/reports/jasmine.log')
    def npmDebugLog = file("$buildDir/npm-debug.log")

    inputs.dir file('build/webjarJs')
    inputs.dir file('src/main/resources/static/app')
    inputs.dir file('src/test/js')
    inputs.file file('karma.conf.js')
    inputs.file file('package.json')

    outputs.file jasmineLog

    args = ['run', 'single-run']

    execOverrides {
        it.workingDir = 'build'
        it.standardOutput = new FileOutputStream(jasmineLog)
        it.errorOutput = new FileOutputStream(npmDebugLog)
        it.ignoreExitValue = true
    }

    doFirst {
        jasmineLog.parentFile.mkdirs()
        npmDebugLog.delete()
    }

    doLast {
        if (npmDebugLog.exists()) {
            throw new RuntimeException("Jasmine tests failed, see " + jasmineLog + " or " + npmDebugLog);
        }
    }
}

task jasmineWatch(type: NpmTask) {
    group = "Verification"
    description = "Runs the Jasmine tests as soon as any source or test is changed."
    dependsOn npmInstall, unpackWebjars

    args = ['run', 'watch']
}

if (!System.properties['os.name'].contains("indows")) {
    check.dependsOn jasmineSingleRun
}

flyway {
    url = "jdbc:h2:tcp://localhost/$databasePath;AUTO_SERVER=TRUE"
    user = 'codekvast'
    password = 'codekvast'
    locations = ['classpath:/database/migration', 'classpath:/se/crisp/codekvast/server/codekvast_server/migration']
}

task startH2Server {
    description "Starts a H2 server, so that one can inspect the database without Codekvast Server running"
    group "Help"

    outputs.upToDateWhen {
        ["jps", "-l"].execute().text.contains('org.h2.tools.Server')
    }

    doLast {
        logger.lifecycle "Starting an H2 server..."
        def process = ["java", "-cp", configurations.h2server.asPath, "-Duser.dir=${buildDir.absolutePath}",
                       'org.h2.tools.Server', "-tcp"].execute()
        process.in.close()
        process.out.close()
        process.err.close()
    }
}
run.dependsOn startH2Server
bootRun.dependsOn startH2Server

task stopH2Server {
    description "Stops the H2 server"
    group "Help"

    outputs.upToDateWhen {
        !["jps", "-l"].execute().text.contains('org.h2.tools.Server')
    }

    doLast {
        logger.lifecycle "Shutting down the H2 server..."
        def process = ["java", "-cp", configurations.h2server.asPath, 'org.h2.tools.Server', "-tcpShutdown", "tcp://localhost"].execute()

        process.in.close()
        process.out.close()
        process.err.close()
    }
}

task copyJdbcDriver(type: Sync) {
    // Copy the H2 JDBC driver jar to a known location so that IDEs can find it...
    from configurations.h2server
    into file("build/jdbcDriver")
}

build.dependsOn copyJdbcDriver
