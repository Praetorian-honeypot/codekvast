import org.apache.tools.ant.filters.ReplaceTokens
import org.ajoberstar.grgit.Grgit

apply plugin: 'distribution'
apply plugin: 'com.jfrog.bintray'
description = "Modules that belongs to the Codekvast product"

version = codekvastVersion

distributions {
    daemon {
        baseName = 'codekvast-daemon'
        contents {
            from tasks.getByPath(":product:agent:daemon:bootRepackage"), {
                rename { "codekvast-daemon.jar" }
            }
            from tasks.getByPath(":product:agent:daemon:processResources"), {
                include 'exposed-application.properties'
                rename { 'application.properties' }
            }
            from tasks.getByPath(":product:agent:daemon:processResources"), {
                include 'codekvast-collector.conf'
                include 'tomcat/**'
                include '*.sh'
                into 'conf'
            }
            from tasks.getByPath(":product:agent:collector:javaagents"), {
                into "javaagents"
            }
            from tasks.getByPath(":product:docs:asciidoctor"), {
                exclude "html5/**"
                exclude "images/**"
            }
            from file("$rootDir/RELEASE-NOTES.md")
            from file("$rootDir/LICENSE")
        }
    }

    warehouse {
        baseName = 'codekvast-warehouse'
        contents {
            from tasks.getByPath(":product:warehouse:bootRepackage"), {
                rename { "codekvast-warehouse.jar" }
            }
            from tasks.getByPath(":product:warehouse:processResources"), {
                include 'exposed-application.properties'
                rename { 'application.properties' }
            }
            from tasks.getByPath(":product:docs:asciidoctor"), {
                exclude "html5/**"
                exclude "images/**"
            }
            from file("$rootDir/RELEASE-NOTES.md")
            from file("$rootDir/LICENSE")
        }
    }

    ansible {
        baseName = 'codekvast-ansible'
        contents {
            from file("src/dist/ansible"), {
                filter(ReplaceTokens, tokens: gitVersionTokens + ['gradle.version'       : project.version,
                                                                  'bintrayDownloadPrefix': project.ext.bintrayDownloadPrefix.toString()])
            }
        }
    }
}

bintray {
    // These are supposed to be defined in $HOME/.gradle/gradle.properties
    user = project.hasProperty('bintrayUser') ? bintrayUser : "undefined"
    key = project.hasProperty('bintrayKey') ? bintrayKey : "undefined"

    filesSpec {
        from tasks.getByPath(":product:daemonDistTar")
        from tasks.getByPath(":product:warehouseDistTar")
        from tasks.getByPath(":product:ansibleDistTar")
        from tasks.getByPath(":product:ansibleDistZip")

        from tasks.getByPath(":product:docs:asciidoctor"), {
            include "CodekvastUserManual.html"
            rename { "CodekvastUserManual-${version}.html" }
        }

        from file("$rootDir/product/warehouse/docker-compose.yml"), {
            rename { "docker-compose-${version}.yml" }
        }

        from file("$rootDir/RELEASE-NOTES.md"), {
            rename { "RELEASE-NOTES-${version}.md" }
        }

        into "."
    }

    dryRun = false
    publish = true

    pkg {
        userOrg = bintrayUserOrg
        repo = bintrayRepo
        name = 'distributions'
        desc = 'Codekvast is a Runtime Intelligence tool used for identifying Truly Dead Code, i.e., code that no-one has accessed in a certain period of time'
        websiteUrl = 'https://codekvast.crisp.se'
        vcsUrl = 'https://github.com/crispab/codekvast.git'
        licenses = ['MIT']
        labels = ['runtime-intelligence', 'dead-code', 'dead-code-detector', 'truly-dead-code', 'YANIA', 'java', 'java-6', 'jvm']
        githubRepo = 'crispab/codekvast'
        githubReleaseNotesFile = 'RELEASE-NOTES.md'

        publicDownloadNumbers = true
    }
}

bintrayUpload {
    doFirst {
        def gradleProperties = new File(System.properties['user.home'], ".gradle/gradle.properties")
        if (!project.hasProperty('bintrayUser')) {
            throw new IllegalArgumentException("You must define bintrayUser in $gradleProperties before trying to upload to Bintray")
        }
        if (!project.hasProperty('bintrayKey')) {
            throw new IllegalArgumentException("You must define bintrayKey in $gradleProperties before trying to upload to Bintray")
        }
    }
}

task assertCleanWorkspace(type: Exec) {
    description "Asserts that the Git workspace is clean before publishing to Bintray and Docker Hub"
    group "publishing"

    commandLine 'git', 'status', '--short'
    workingDir rootDir
    standardOutput = new ByteArrayOutputStream()

    doLast {
        def status = standardOutput.toString().trim()
        if (!status.isEmpty()) {
            throw new IllegalStateException("""Will not ship when Git workspace is dirty:

$status""")
        }
    }
}

task assertPushedWorkspace(type: Exec) {
    description "Asserts that the Git workspace is pushed before publishing to Bintray and Docker Hub"
    group "publishing"
    dependsOn assertCleanWorkspace
    commandLine 'git', 'status', '--short', '--branch'
    workingDir rootDir
    standardOutput = new ByteArrayOutputStream()

    doLast {
        def status = standardOutput.toString().trim()
        if (status.contains("[ahead ")) {
            throw new IllegalStateException("""Will not ship when Git workspace is ahead of origin:

$status""")
        }
    }
}

task shipIt {
    description "Builds and uploads to bintray"
    group = "publishing"

    dependsOn assertPushedWorkspace,
            clean,
            build,
            tasks.getByPath(":product:bintrayUpload"),
            tasks.getByPath(":product:agent:collector:bintrayUpload"),
            tasks.getByPath(":product:warehouse:pushDockerImage")
}
